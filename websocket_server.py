# -*- coding: utf-8 -*-
"""Websocket-server.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1A5QU2aEOyz9JAivm-u5npGtcbOJXZm_e
"""

import logging
from fastapi import FastAPI, WebSocket
import torch
import torchaudio
from transformers import AutoProcessor, SeamlessM4Tv2Model
import io
import uvicorn

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

app = FastAPI()

model = SeamlessM4Tv2Model.from_pretrained("facebook/seamless-m4t-v2-large")
processor = AutoProcessor.from_pretrained("facebook/seamless-m4t-v2-large")

device = "cuda:0" if torch.cuda.is_available() else "cpu"
model = model.to(device)

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    try:
        while True:
            data = await websocket.receive_bytes()
            logger.info("Received audio data")
            audio_sample = process_audio_data(data)
            translated_text = translate_audio(audio_sample)
            logger.info(f"Translated text: {translated_text}")
            await websocket.send_text(translated_text)
    except Exception as e:
        logger.error(f"An error occurred: {e}")
        await websocket.close()


def translate_audio(audio_sample):
    try:
        audio = torch.tensor(audio_sample["array"])
        audio = torchaudio.functional.resample(audio, orig_freq=audio_sample['sampling_rate'], new_freq=model.config.sampling_rate)
        audio_inputs = processor(audio, return_tensors="pt").to(device)
        output_tokens = model.generate(**audio_inputs, tgt_lang="eng", generate_speech=False)
        translated_text = processor.decode(output_tokens[0].tolist(), skip_special_tokens=True)
        return translated_text


def process_audio_data(data):
        # Save the incoming data to a file for debugging
   debug_file_path = 'debug_audio_data'
   with open(debug_file_path, 'wb') as debug_file:
        debug_file.write(data)

   with io.BytesIO(data) as f:
         waveform, sample_rate = torchaudio.load(f)
   audio_sample = {"array": waveform, "sampling_rate": sample_rate}
   return audio_sample

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8008)